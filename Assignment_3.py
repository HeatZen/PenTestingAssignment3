#! /usr/bin/python

from logging import getLogger, ERROR
getLogger("scapy.runtime").setLevel(ERROR)
from scapy.all import *
import sys

#-------------------------- TCP Port Scan ---------------------------------------------------
#--------------------- User input and verifies that it is valid -----------------------------
try:
    print "<<<<<This is a TCP and UDP port scanner. We use ICMP to verify the machine is online>>>>>\n"
    target_ip = raw_input("Target IP Address:")                #User input for target IP address
    begin_port = raw_input("Starting Port Number:")            #User input for starting port number
    end_port = raw_input("Ending Port Number:")                #User input for ending port number
    try:
        if int(begin_port) >= 0 and int(end_port) >= 0 and int(end_port) >= int(begin_port):    #Verify that the port range works
        	pass
        else:
            print "\nInvalid port range"       #If port range doesn't work, exit the system
            sys.exit(1)
    except Exception:
    	print "\nInvalid port range"           #If port range of IP address doesn't work, exit the system
    	sys.exit(1)
except Exception:
	print "\nInvalid"
	sys.exit(1)
#--------------------- Define port range to be used -----------------------------------------
port_range = range(int(begin_port), int(end_port)+1)     #Set the range and include the end port by adding one to it

#--------------------- Check if target is online using the ICMP protocol --------------------
def target_available (use_target_ip):
    conf.verb = 0
    ping = sr1(IP(dst = use_target_ip)/ICMP(), timeout = 2)      #sr1 is used to send and recieve 1 packet. sr1 function binds the values together to create the ping packet needed and defines the protocol to be ICMP()
    if not (ping is None):
    	print "\nHost online... \nBeginning scan..." 
    else:
	print "\nHost couldn't be found... \nExiting..."
	sys.exit(1)

#--------------------- TCP port scan function -----------------------------------------------
def tcp_scan(port):
    src_port = RandShort()              #Random number generator to use as a source port and conceal identity
    conf.verb = 0                       #Doesn't output the packets being sent on the screen
    syn_ack_pkt = sr1(IP(dst = target_ip)/TCP(sport = src_port, dport = port, flags = "S"))        #Setting up the SYN-ACK packet and the value returned is stored in the variable
    pkt_flags = syn_ack_pkt.getlayer(TCP).flags                           #We get the flags from the packet received and assign to a variable
    if pkt_flags == 0x12:               #0x12 is the SYN-ACK value returned in the packet
	rst_pkt = IP(dst = target_ip)/TCP(sport = src_port, dport = port, flags = "R")     #This is the RST packet and we don't expect a packet returned
    	send(rst_pkt)                                                                      #Send the RST packet        
	return True                     #If we do recieve a SYN-ACK flag, then we return true
    else:
        return False                    #Else we return false
    

#-------------------------- TCP port scan ----------------------------------------------------
target_available(target_ip)
for port in port_range:
    status = tcp_scan(port)
    if status == True:               #If the packet recieved is the SYN-ACK flag, then the function returns true and the port is open
        print "\nTCP Port " + str(port) + " is Open"
print "\n\n"

#-------------------------- UDP Port Scan ---------------------------------------------------
src_port = RandShort()              #Set variable to use random number for source port
for port in port_range:                  #For loop to go through the range of ports given
	packet = sr1(IP(dst = target_ip)/UDP(sport = src_port, dport = port), timeout = 2, verbose = 0)     #Initialize UDP packet, send 1 packet, and receive. If no response, timeout after 2 seconds
	if packet == None:
		print "\nUDP Port " + str(port) + " is Open or Filtered"      #If no packet is returned then it either works or hit a firewall
	elif packet.haslayer(UDP):
		print "\nUDP Port " + str(port) + " is Open or Filtered"            #If we get an UDP return packet, then it is open or filtered